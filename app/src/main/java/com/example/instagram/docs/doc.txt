inner class TouchHelper(val adapter: ChatAdapter) : ItemTouchHelper.SimpleCallback(0, 0) {
        var hapticFlag = true

        override fun onMove(recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder, target: RecyclerView.ViewHolder): Boolean {
            return false
        }

        override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) {
            Log.e(TAG, "onSwiped: called")

            val adapterPos = (viewHolder.itemView.tag as Pair<Int, Int>).first
            adapter.notifyItemChanged(adapterPos)

            //            haptics.light()
            /*val animator = ValueAnimator.ofFloat(viewHolder.itemView.translationX, 0f)
            animator.addUpdateListener { animation ->
                viewHolder.itemView.translationX = animation.animatedValue as Float
            }
            animator.duration = 200
            animator.start()*/
            //            itemTouchHelper.attachToRecyclerView(null)
            //            itemTouchHelper.attachToRecyclerView(binding.chatRV)


            chatViewModel.replyToChat = chatViewModel.chatAdapter?.chats?.get((viewHolder.itemView.tag as Pair<Int, Int>).first)
            bindDataInReplyPreview()
            showReplyPreview()

            //            Log.e(TAG, "onSwiped ENDED")
        }

        /**
         * Returns the fraction that the user should move the View to be considered as swiped.
         * The fraction is calculated with respect to RecyclerView's bounds.
         *
         *
         * Default value is .5f, which means, to swipe a View, user must move the View at least
         * half of RecyclerView's width or height, depending on the swipe direction.
         *
         * @param viewHolder The ViewHolder that is being dragged.
         * @return A float value that denotes the fraction of the View size. Default value
         * is .5f .
         */
        override fun getSwipeThreshold(viewHolder: RecyclerView.ViewHolder): Float {
            return .15f
        }

        /**
         * Defines the minimum velocity which will be considered as a swipe action by the user.
         *
         *
         * You can increase this value to make it harder to swipe or decrease it to make it easier.
         * Keep in mind that ItemTouchHelper also checks the perpendicular velocity and makes sure
         * current direction velocity is larger then the perpendicular one. Otherwise, user's
         * movement is ambiguous. You can change the threshold by overriding
         * [.getSwipeVelocityThreshold].
         *
         *
         * The velocity is calculated in pixels per second.
         *
         *
         * The default framework value is passed as a parameter so that you can modify it with a
         * multiplier.
         *
         * @param defaultValue The default value (in pixels per second) used by the
         * ItemTouchHelper.
         * @return The minimum swipe velocity. The default implementation returns the
         * `defaultValue` parameter.
         * @see .getSwipeVelocityThreshold
         * @see .getSwipeThreshold
         */
        override fun getSwipeEscapeVelocity(defaultValue: Float): Float {
            Log.d(TAG, "getSwipeEscapeVelocity: defaultValue = $defaultValue")
            return 4000f
        }

        /**
         * Defines the maximum velocity ItemTouchHelper will ever calculate for pointer movements.
         *
         *
         * To consider a movement as swipe, ItemTouchHelper requires it to be larger than the
         * perpendicular movement. If both directions reach to the max threshold, none of them will
         * be considered as a swipe because it is usually an indication that user rather tried to
         * scroll then swipe.
         *
         *
         * The velocity is calculated in pixels per second.
         *
         *
         * You can customize this behavior by changing this method. If you increase the value, it
         * will be easier for the user to swipe diagonally and if you decrease the value, user will
         * need to make a rather straight finger movement to trigger a swipe.
         *
         * @param defaultValue The default value(in pixels per second) used by the ItemTouchHelper.
         * @return The velocity cap for pointer movements. The default implementation returns the
         * `defaultValue` parameter.
         * @see .getSwipeEscapeVelocity
         */
        override fun getSwipeVelocityThreshold(defaultValue: Float): Float {
            Log.d(TAG, "getSwipeVelocityThreshold: defaultValue = $defaultValue")
            return super.getSwipeVelocityThreshold(defaultValue)
        }

        /**
         * Called when the ViewHolder swiped or dragged by the ItemTouchHelper is changed.
         *
         *
         * If you override this method, you should call super.
         *
         * @param viewHolder  The new ViewHolder that is being swiped or dragged. Might be null if
         * it is cleared.
         * @param actionState One of [ItemTouchHelper.ACTION_STATE_IDLE],
         * [ItemTouchHelper.ACTION_STATE_SWIPE] or
         * [ItemTouchHelper.ACTION_STATE_DRAG].
         * @see .clearView
         */
        override fun onSelectedChanged(viewHolder: RecyclerView.ViewHolder?, actionState: Int) {
            super.onSelectedChanged(viewHolder, actionState)
        }

        override fun onChildDraw(c: Canvas, recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder, dX: Float, dY: Float, actionState: Int, isCurrentlyActive: Boolean) {
            //            Log.d(TAG, "onChildDraw: ")
            val allowedSwipe = viewHolder.itemView.width / 5.toFloat()
            val clampedDX = dX.coerceIn(-allowedSwipe, allowedSwipe)
            super.onChildDraw(c, recyclerView, viewHolder, clampedDX, dY, actionState, isCurrentlyActive)
            if (clampedDX >= (viewHolder.itemView.width * .15) && isCurrentlyActive && hapticFlag) {
                hapticFlag = false
                haptics.light()
            }

            if (!isCurrentlyActive) {
                hapticFlag = true
            }


            Log.d(
                TAG, "onChildDraw: \n" +
                        "maxSwipe = $allowedSwipe\n" +
                        "dX = $dX\n" +
                        "clammed = $clampedDX\n" +
                        "dY = $dY\n" +
                        "actionState = $actionState\n" +
                        "isCurrentlyActive = $isCurrentlyActive"
            )
        }

        /**
         * Statistics shown:
         *
         * The number of current touch points ("P") and the maximum number of touch points that have been detected since last removing all points.
         *
         * The coordinates of the touch point relative to the screen ("X" and "Y"). If there are multiple touch points, this tracks only the first.
         *
         * The velocity/vector of the touch point as a delta in the X and Y direction ("Xv" and "Yv"). When the touch point stops moving, this continues to show the most recent reading.
         *
         * The pressure being applied ("Prs"). Typical capacitative touch screen devices are unable to sense actual pressure but may estimate the pressure based on the estimated size of the touch point.
         *
         * The size of the touch point ("Siz"). Capacitative touch screens will estimate this based on the strength and spread of the capacitative response on a point.
         *
         * After removing your finger, the total delta between the entry and exit points will be shown ("dX", "dY") showing how far away the point your finger left the screen is from the point where it landed on the screen.
         *
         * All these statistics reset after all touch points (all fingers) disappear from the screen and you start again by placing a new finger on the screen.
         */

        override fun getSwipeDirs(recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder): Int {
            val pair = viewHolder.itemView.tag as Pair<Int, Int>
            return when (pair.second) {
                REGULAR_SENT, REPLY_SENT, REGULAR_RECEIVED, REPLY_RECEIVED -> ItemTouchHelper.RIGHT
                else -> 0
            }
        }
    }

    // the swipe is working for dX and dY
    // now working with the escape velocity and threshold



    2....


        inner class TouchHelper(val adapter: ChatAdapter) : ItemTouchHelper.SimpleCallback(0, 0) {
            var hapticFlag = true

            override fun onMove(recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder, target: RecyclerView.ViewHolder): Boolean {
                return false
            }

            override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) {
                Log.e(TAG, "onSwiped: called")
                //            adapter.notifyItemChanged(viewHolder.adapterPosition)

                //            haptics.light()
                /*val animator = ValueAnimator.ofFloat(viewHolder.itemView.translationX, 0f)
                animator.addUpdateListener { animation ->
                    viewHolder.itemView.translationX = animation.animatedValue as Float
                }
                animator.duration = 200
                animator.start()*/
                /*itemTouchHelper.attachToRecyclerView(null)
                itemTouchHelper.attachToRecyclerView(binding.chatRV)*/

                /*val translationX = ObjectAnimator.ofFloat(viewHolder.itemView, View.TRANSLATION_X, ((viewHolder.itemView.width / 5).toFloat()), 0f)
                translationX.duration = 120
                translationX.start()*/
                /*chatViewModel.replyToChat = chatViewModel.chatAdapter?.chats?.get(viewHolder.adapterPosition)
                bindDataInReplyPreview()
                showReplyPreview()*/

                // Log.e(TAG, "onSwiped ENDED")
            }

            override fun getSwipeThreshold(viewHolder: RecyclerView.ViewHolder): Float {
                return /*.10f*/ Float.MAX_VALUE
            }

            override fun getSwipeEscapeVelocity(defaultValue: Float): Float {
                Log.d(TAG, "getSwipeEscapeVelocity: defaultValue = $defaultValue")
                return Float.MAX_VALUE
            }

            override fun getSwipeVelocityThreshold(defaultValue: Float): Float {
                Log.d(TAG, "getSwipeVelocityThreshold: defaultValue = $defaultValue")
                return 0.001f
            }

            override fun onChildDraw(c: Canvas, recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder, dX: Float, dY: Float, actionState: Int, isCurrentlyActive: Boolean) {
                // Log.d(TAG, "onChildDraw: ")
                val allowedSwipe = (viewHolder.itemView.width / 5).toFloat()
                val clampedDX = dX.coerceIn(-allowedSwipe, allowedSwipe)
                super.onChildDraw(c, recyclerView, viewHolder, clampedDX, dY, actionState, isCurrentlyActive)
                /*if (clampedDX >= (viewHolder.itemView.width * .1) && isCurrentlyActive && hapticFlag) {
                    hapticFlag = false
                    haptics.light()
                    chatViewModel.replyToChat = chatViewModel.chatAdapter?.chats?.get(viewHolder.adapterPosition)
                    bindDataInReplyPreview()
                    showReplyPreview()
                }*/

                if(isCurrentlyActive) hapticFlag = true

                if (clampedDX < 1 && !isCurrentlyActive && hapticFlag) {
                    hapticFlag = false
                    haptics.light()
                    chatViewModel.replyToChat = chatViewModel.chatAdapter?.chats?.get(viewHolder.adapterPosition)
                    bindDataInReplyPreview()
                    showReplyPreview()

                }

                Log.d(
                    TAG, "onChildDraw: \n" +
                            "maxSwipe = $allowedSwipe\n" +
                            "dX = $dX\n" +
                            "clammed = $clampedDX\n" +
                            "dY = $dY\n" +
                            "actionState = $actionState\n" +
                            "isCurrentlyActive = $isCurrentlyActive"
                )
            }

            override fun getSwipeDirs(recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder): Int {
                val pair = viewHolder.itemView.tag as Pair<Int, Int>
                return when (pair.second) {
                    REGULAR_SENT, REPLY_SENT, REGULAR_RECEIVED, REPLY_RECEIVED -> ItemTouchHelper.RIGHT
                    else -> 0
                }
            }
        }

    3 .....

    inner class TouchHelper(val adapter: ChatAdapter) : ItemTouchHelper.SimpleCallback(0, 0) {
            private var replyPreviewFlag = true
            private var hapticCounter = true


            override fun onMove(recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder, target: RecyclerView.ViewHolder): Boolean {
                return false
            }

            override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) {
                Log.e(TAG, "onSwiped: called")
                //            adapter.notifyItemChanged(viewHolder.adapterPosition)

                //            haptics.light()
                /*val animator = ValueAnimator.ofFloat(viewHolder.itemView.translationX, 0f)
                animator.addUpdateListener { animation ->
                    viewHolder.itemView.translationX = animation.animatedValue as Float
                }
                animator.duration = 200
                animator.start()*/
                /*itemTouchHelper.attachToRecyclerView(null)
                itemTouchHelper.attachToRecyclerView(binding.chatRV)*/

                /*val translationX = ObjectAnimator.ofFloat(viewHolder.itemView, View.TRANSLATION_X, ((viewHolder.itemView.width / 5).toFloat()), 0f)
                translationX.duration = 120
                translationX.start()*/
                /*chatViewModel.replyToChat = chatViewModel.chatAdapter?.chats?.get(viewHolder.adapterPosition)
                bindDataInReplyPreview()
                showReplyPreview()*/

                // Log.e(TAG, "onSwiped ENDED")
            }

            override fun getSwipeThreshold(viewHolder: RecyclerView.ViewHolder): Float {
                return /*.10f*/ Float.MAX_VALUE
            }

            override fun getSwipeEscapeVelocity(defaultValue: Float): Float {
                Log.d(TAG, "getSwipeEscapeVelocity: defaultValue = $defaultValue")
                return Float.MAX_VALUE
            }

            override fun getSwipeVelocityThreshold(defaultValue: Float): Float {
                Log.d(TAG, "getSwipeVelocityThreshold: defaultValue = $defaultValue")
                return 0.001f
            }


            override fun onChildDraw(c: Canvas, recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder, dX: Float, dY: Float, actionState: Int, isCurrentlyActive: Boolean) {
                // Log.d(TAG, "onChildDraw: ")
                val allowedSwipe = (viewHolder.itemView.width / 5).toFloat()
                val clampedDX = dX.coerceIn(-allowedSwipe, allowedSwipe)
                super.onChildDraw(c, recyclerView, viewHolder, clampedDX, dY, actionState, isCurrentlyActive)
                if (clampedDX >= (viewHolder.itemView.width * .1) && isCurrentlyActive && replyPreviewFlag) {
                    replyPreviewFlag = false
                    if (hapticCounter) {
                        hapticCounter = false
                        haptics.light()
                    }
                }

                if (clampedDX < (viewHolder.itemView.width * .1) && isCurrentlyActive) {
                    replyPreviewFlag = true
                }
                if (clampedDX == 0f && !isCurrentlyActive) {
                    hapticCounter = true
                }


                /*Log.d(
                    TAG, "onChildDraw: \n" +
                            "maxSwipe = $allowedSwipe\n" +
                            "dX = $dX\n" +
                            "clammed = $clampedDX\n" +
                            "dY = $dY\n" +
                            "actionState = $actionState\n" +
                            "isCurrentlyActive = $isCurrentlyActive"
                )*/
            }


            override fun clearView(recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder) {
                super.clearView(recyclerView, viewHolder)
                if (!replyPreviewFlag) {
                    replyPreviewFlag = true
                    chatViewModel.replyToChat = chatViewModel.chatAdapter?.chats?.get(viewHolder.adapterPosition)
                    bindDataInReplyPreview()
                    showReplyPreview()
                }
                Log.d(TAG, "clearView: ")

            }

            override fun getSwipeDirs(recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder): Int {
                val pair = viewHolder.itemView.tag as Pair<Int, Int>
                return when (pair.second) {
                    REGULAR_SENT, REPLY_SENT, REGULAR_RECEIVED, REPLY_RECEIVED -> ItemTouchHelper.RIGHT
                    else -> 0
                }
            }
        }


